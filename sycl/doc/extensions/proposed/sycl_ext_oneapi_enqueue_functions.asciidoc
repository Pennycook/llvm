= sycl_ext_oneapi_enqueue_functions

:source-highlighter: coderay
:coderay-linenums-mode: table

// This section needs to be after the document title.
:doctype: book
:toc2:
:toc: left
:encoding: utf-8
:lang: en
:dpcpp: pass:[DPC++]

// Set the default source code type in this document to C++,
// for syntax highlighting purposes.  This is needed because
// docbook uses c++ and html5 uses cpp.
:language: {basebackend@docbook:c++:cpp}


== Notice

[%hardbreaks]
Copyright (C) 2023-2023 Intel Corporation.  All rights reserved.

Khronos(R) is a registered trademark and SYCL(TM) and SPIR(TM) are trademarks
of The Khronos Group Inc.  OpenCL(TM) is a trademark of Apple Inc. used by
permission by Khronos.


== Contact

To report problems with this extension, please open a new issue at:

https://github.com/intel/llvm/issues


== Dependencies

This extension is written against the SYCL 2020 revision 7 specification.  All
references below to the "core SYCL specification" or to section numbers in the
SYCL specification refer to that revision.


== Status

This is a proposed extension specification, intended to gather community
feedback.  Interfaces defined in this specification may not be implemented yet
or may be in a preliminary state.  The specification itself may also change in
incompatible ways before it is finalized.  *Shipping software products should
not rely on APIs defined in this specification.*


== Overview

SYCL 2020 provides multiple ways to enqueue work to a device. In some cases, a
single function name is used to enqueue kernels with very different use-cases
and execution models (e.g., `parallel_for(range)` and
`parallel_for(nd_range)`). In almost all cases, the functions are available in
multiple places (e.g., `queue::parallel_for` and `handler::parallel_for`).
In all cases, these functions return an `event` object by default, which has
been shown to introduce undesirable performance overhead.

Additionally, we have received feedback from developers and implementers alike
that the number of `parallel_for` overloads is confusing, and that the way
reductions in particular are specified (as a parameter pack containing both
`sycl::reduction` objects and a kernel lambda) is problematic.

This extension addresses these issues by:

1. Using different function names for different use-cases.
2. Using free-functions instead of member functions.
3. Requiring developers to opt-in to the creation of `event` objects.
4. Bundling everything related to a kernel's launch configuration (i.e., its
range, any properties, and any reductions) into a single object.

This extension makes SYCL simpler and easier to document. It is also expected
to improve the performance of many SYCL applications, where `event` objects are
not required to describe application behavior.

All functions proposed in this extension accept as their first argument an
object that represents where a command should be submitted. For now, we refer
to this as an "Executor". This argument can currently be either a
`sycl::handler` or a `sycl::queue`, allowing the new functions to be used
either at command-group scope or as a replacement for existing queue shortcuts.
It is expected that a future version of this extension will adjust this
overload set to include functions compatible with future C++ concepts (such as
senders and receivers).


=== Usage example

The example below demonstrates that the syntax proposed here requires only
minor changes to existing applications, while retaining their structure.


==== SYCL 2020

[source,c++]
----
q.submit([&](sycl::handler& h) {
  sycl::accessor result { buf, h, sycl::write_only, sycl::no_init };
  h.parallel_for(1024, [=](sycl::id<1> idx) {
    result[idx] = idx;
  });
});

float* output = sycl::malloc_shared<int>(1, q);
*output = 0;
std::vector<sycl::event> depEvents = /* some dependencies */;
sycl::event e = q.parallel_for(sycl::nd_range<1>{1024, 16}, depEvents,
  sycl::reduction(output, sycl::plus<>()),
  [=](sycl::nd_item<1> it, auto& sum) {
  sum += it.get_global_id();
});
e.wait();
sycl::free(output, q);
----


==== Proposed syntax

[source,c++]
----
using syclex = sycl::ext::oneapi::experimental;

syclex::submit(q, [&](sycl::handler& h) {
  sycl::accessor result { buf, h, sycl::write_only, sycl::no_init };
  syclex::parallel_for(h, 1024, [=](sycl::id<1> idx) {
    result[idx] = idx;
  });
});

float* output = sycl::malloc_shared<int>(1, q);
*output = 0;
std::vector<sycl::event> depEvents = /* some dependencies */;
sycl::event e;
syclex::nd_launch(q,
  syclex::launch_config(sycl::nd_range<1>{1024, 16}, sycl::reduction(output, sycl::plus<>())),
  [=](sycl::nd_item<1> it, auto& sum) {
  sum += it.get_global_id();
}, depEvents, &e);
e.wait();
sycl::free(output, q);
----


== Specification

=== Feature test macro

This extension provides a feature-test macro as described in the core SYCL
specification.  An implementation supporting this extension must predefine the
macro `SYCL_EXT_ONEAPI_ENQUEUE_FUNCTIONS` to one of the values defined in the
table below.  Applications can test for the existence of this macro to
determine if the implementation supports this feature, or applications can test
the macro's value to determine which of the extension's features the
implementation supports.

[%header,cols="1,5"]
|===
|Value
|Description

|1
|The APIs of this experimental extension are not versioned, so the
 feature-test macro always has this value.
|===


=== Launch configuration

A launch configuration object of type `launch_config` is used to bundle
together all components of a kernel's launch configuration, including:

1. The range of execution.
2. Any compile-time properties.
3. Any reductions.

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

template </* unspecified */>
class launch_config
{
public:

  launch_config(Properties p);

  // Available only when:
  // 1) Range is sycl::range or sycl::nd_range
  // 2) Reductions is a parameter pack of sycl::reduction
  launch_config(Range r, Reductions... reductions);

  // Available only when:
  // 1) Range is sycl::range or sycl::nd_range
  // 2) Properties is a compile-time property list
  // 3) Reductions is a parameter pack of sycl::reduction
  launch_config(Range r, Properties, Reductions... reductions);

};

}
----

[NOTE]
====
The template parameters for `launch_config` are currently unspecified, while we
gain implementation experience. An implementation must be able to identify and
extract the type of range (`sycl::range`, `sycl::nd_range`, or no range) and
other properties from the `launch_config`.
====

[source,c++]
----
launch_config(Properties p);
----
_Effects_: Constructs a `launch_config` with no range or reductions.

[NOTE]
====
The only current use-case for this constructor is to create a `launch_config`
used to pass properties to `single_task`.
====

[source,c++]
----
launch_config(Range r, Reductions... reductions);
----
_Constraints_: Available only if `Range` is a `sycl::range` or
`sycl::nd_range`, and `Reductions` is a parameter pack of `sycl::reduction`.

_Effects_: Constructs a `launch_config` from the specified range and
reductions.

[NOTE]
====
Because this constructor accepts an empty parameter pack, it remains possible
to enqueue a kernel as `sycl::parallel_for(q, range, lambda)`, and avoid
explicitly typing `launch_config()` in simple cases.
====

[source,c++]
----
launch_config(Range r, Properties, Reductions... reductions);
----
_Constraints_: Available only if `Range` is a `sycl::range` or
`sycl::nd_range`, `Properties` is a compile-time property list,
and `Reductions` is a parameter pack of `sycl::reduction`.

_Effects_: Constructs a `launch_config` from the specified range,
properties and reductions.


=== Command group submission

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

template <typename ExecutorType, typename CommandGroupFunc>
void submit(ExecutorType ex, CommandGroupFunc&& cgf, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);

}
----

[source,c++]
----
template <typename ExecutorType, typename CommandGroupFunc>
void submit(ExecutorType ex, CommandGroupFunc&& cgf, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);
----
_Constraints_: Available only if `ExecutorType` is `sycl::queue`.

_Effects_: Submit a command group function object to be scheduled for execution
on `ex`. The submitted command will not execute until each of the events in
`depEvents` is complete. An optional event representing this command can be
returned via `outEvent`.


=== Single tasks

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

template <typename KernelName, typename ExecutorType, typename KernelType>
void single_task(ExecutorType ex, const KernelType& kernelFunc);

template <typename KernelName, typename ExecutorType, typename KernelType, typename LaunchConfig>
void single_task(ExecutorType ex, LaunchConfig lc, const KernelType& kernelFunc);

template <typename KernelName, typename ExecutorType, typename KernelType>
void single_task(ExecutorType ex, const KernelType& kernelFunc, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);

template <typename KernelName, typename ExecutorType, typename KernelType, typename LaunchConfig>
void single_task(ExecutorType ex, LaunchConfig lc, const KernelType& kernelFunc, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);

}
----

[source,c++]
----
template <typename KernelName, typename ExecutorType, typename KernelType>
void single_task(ExecutorType ex, const KernelType& kernelFunc);
----
_Constraints_: Available only if `ExecutorType` is `sycl::handler`.

_Effects_: Enqueues a single task to the executor `ex`.

[source,c++]
----
template <typename KernelName, typename ExecutorType, typename KernelType, typename LaunchConfig>
void single_task(ExecutorType ex, LaunchConfig lc, const KernelType& kernelFunc);
----
_Constraints_: Available only if `ExecutorType` is `sycl::handler`, and
`LaunchConfig` is convertible to `launch_config`.

_Effects_: Enqueues a single task to the executor `ex` with the specified
launch configuration.


[source,c++]
----
template <typename KernelName, typename ExecutorType, typename KernelType>
void single_task(ExecutorType ex, const KernelType& kernelFunc, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);
----
_Constraints_: Available only if `ExecutorType` is `sycl::queue`.

_Effects_: Enqueues a single task to the executor `ex`. The command will not
execute until each of the events in `depEvents` is complete. An optional
event representing this command can be returned via `outEvent`.


[source,c++]
----
template <typename KernelName, typename ExecutorType, typename KernelType, typename LaunchConfig>
void single_task(ExecutorType ex, LaunchConfig lc, const KernelType& kernelFunc, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);
----
_Constraints_: Available only if `ExecutorType` is `sycl::queue`, and
`LaunchConfig` is convertible to `launch_config`.

_Effects_: Enqueues a single task to the executor `ex` with the specified
launch configuration. The command will not execute until each of the events in
`depEvents` is complete. An optional event representing this command can be
returned via `outEvent`.


=== Basic kernels

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

template <typename KernelName, typename ExecutorType, typename LaunchConfig, typename KernelType>
void parallel_for(ExecutorType ex, LaunchConfig lc, const KernelType& kernelFunc);

template <typename KernelName, typename ExecutorType, typename LaunchConfig, typename KernelType>
void parallel_for(ExecutorType ex, LaunchConfig lc, const KernelType& kernelFunc, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);

}
----

[source,c++]
----
template <typename KernelName, typename ExecutorType, typename LaunchConfig, typename KernelType>
void parallel_for(ExecutorType ex, LaunchConfig lc, const KernelType& kernelFunc);
----
_Constraints_: Available only if `ExecutorType` is `sycl::handler`,
`LaunchConfig` is `launch_config`, and the launch configuration was constructed
from a `sycl::range`.

_Effects_: Enqueues a basic kernel to the executor `ex` with the specified
launch configuration.


[source,c++]
----
template <typename KernelName, typename ExecutorType, typename LaunchConfig, typename KernelType>
void parallel_for(ExecutorType ex, LaunchConfig lc, const KernelType& kernelFunc, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);
----
_Constraints_: Available only if `ExecutorType` is `sycl::queue`,
`LaunchConfig` is convertible to `launch_config`, and the constructed launch
configuration is associated with a `sycl::range`.

_Effects_: Enqueues a basic kernel to the executor `ex` with the specified
launch configuration. The command will not execute until each of the events in
`depEvents` is complete. An optional event representing this command can be
returned via `outEvent`.


=== ND-range kernels

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

template <typename KernelName, typename ExecutorType, typename LaunchConfig, typename KernelType>
void nd_launch(ExecutorType ex, LaunchConfig lc, const KernelType& kernelFunc);

template <typename KernelName, typename ExecutorType, typename LaunchConfig, typename KernelType>
void nd_launch(ExecutorType ex, LaunchConfig lc, const KernelType& kernelFunc, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);

}
----

[source,c++]
----
template <typename KernelName, typename ExecutorType, typename LaunchConfig, typename KernelType>
void nd_launch(ExecutorType ex, LaunchConfig lc, const KernelType& kernelFunc);
----
_Constraints_: Available only if `ExecutorType` is `sycl::handler`,
`LaunchConfig` is convertible to `launch_config`, and the constructed launch
configuration is associated with a `sycl::nd_range`.

_Effects_: Enqueues an ND-range kernel to the executor `ex` with the specified
launch configuration.


[source,c++]
----
template <typename KernelName, typename ExecutorType, typename LaunchConfig, typename KernelType>
void nd_launch(ExecutorType ex, LaunchConfig lc, const KernelType& kernelFunc, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);
----
_Constraints_: Available only if `ExecutorType` is `sycl::queue`,
`LaunchConfig` is convertible to `launch_config`, and the constructed launch
configuration is assocaited with a `sycl::nd_range`.

_Effects_: Enqueues an ND-range kernel to the executor `ex` with the specified
launch configuration. The command will not execute until each of the events in
`depEvents` is complete. An optional event representing this command can be
returned via `outEvent`.


=== Memory operations

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

template <typename ExecutorType>
void memcpy(ExecutorType ex, void* dest, const void* src, size_t numBytes);

template <typename ExecutorType>
void memcpy(ExecutorType ex, void* dest, const void* src, size_t numBytes, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);

template <typename ExecutorType, typename T>
void copy(ExecutorType ex, const T* src, T* dest, size_t count);

template <typename ExecutorType, typename T>
void copy(ExecutorType ex, const T* src, T* dest, size_t count, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);

template <typename ExecutorType>
void memset(ExecutorType ex, void* ptr, int value, size_t numBytes);

template <typename ExecutorType>
void memset(ExecutorType ex, void* ptr, int value, size_t numBytes, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);

template <typename ExecutorType, typename T>
void fill(ExecutorType ex, T* ptr, const T& pattern, size_t count);

template <typename ExecutorType, typename T>
void fill(ExecutorType ex, T* ptr, const T& pattern, size_t count, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);

template <typename ExecutorType>
void prefetch(ExecutorType ex, void* ptr, size_t numBytes);

template <typename ExecutorType>
void prefetch(ExecutorType ex, void* ptr, size_t numBytes, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);

template <typename ExecutorType>
void mem_advise(ExecutorType ex, void* ptr, size_t numBytes, int advice);

template <typename ExecutorType>
void mem_advise(ExecutorType ex, void* ptr, size_t numBytes, int advice, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);

}
----

[source,c++]
----
template <typename ExecutorType>
void memcpy(ExecutorType ex, void* dest, const void* src, size_t numBytes);
----
_Constraints_: Available only if `ExecutorType` is `sycl::handler`.

_Effects_: Enqueues a `memcpy` to the executor `ex`.

[source,c++]
----
template <typename ExecutorType>
void memcpy(ExecutorType ex, void* dest, const void* src, size_t numBytes, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);
----
_Constraints_: Available only if `ExecutorType` is `sycl::queue`.

_Effects_: Enqueues a `memcpy` to the executor `ex`. The command will not
execute until each of the events in `depEvents` is complete. An optional event
representing this command can be returned via `outEvent`.

[source,c++]
----
template <typename ExecutorType, typename T>
void copy(ExecutorType ex, const T* src, T* dest, size_t count);
----
_Constraints_: Available only if `ExecutorType` is `sycl::handler`.

_Effects_: Enqueues a `copy` to the executor `ex`.

[source,c++]
----
template <typename ExecutorType, typename T>
void copy(ExecutorType ex, const T* src, T* dest, size_t count, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);
----
_Constraints_: Available only if `ExecutorType` is `sycl::queue`.

_Effects_: Enqueues a `copy` to the executor `ex`. The command will not
execute until each of the events in `depEvents` is complete. An optional event
representing this command can be returned via `outEvent`.

[source,c++]
----
template <typename ExecutorType>
void memset(ExecutorType ex, void* ptr, int value, size_t numBytes);
----
_Constraints_: Available only if `ExecutorType` is `sycl::handler`.

_Effects_: Enqueues a `memset` to the executor `ex`.

[source,c++]
----
template <typename ExecutorType>
void memset(ExecutorType ex, void* ptr, int value, size_t numBytes, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);
----
_Constraints_: Available only if `ExecutorType` is `sycl::queue`.

_Effects_: Enqueues a `memset` to the executor `ex`. The command will not
execute until each of the events in `depEvents` is complete. An optional event
representing this command can be returned via `outEvent`.

[source,c++]
----
template <typename ExecutorType, typename T>
void fill(ExecutorType ex, T* ptr, const T& pattern, size_t count);
----
_Constraints_: Available only if `ExecutorType` is `sycl::handler`.

_Effects_: Enqueues a `fill` to the executor `ex`.

[source,c++]
----
template <typename ExecutorType, typename T>
void fill(ExecutorType ex, T* ptr, const T& pattern, size_t count, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);
----
_Constraints_: Available only if `ExecutorType` is `sycl::queue`.

_Effects_: Enqueues a `fill` to the executor `ex`. The command will not
execute until each of the events in `depEvents` is complete. An optional event
representing this command can be returned via `outEvent`.

[source,c++]
----
template <typename ExecutorType>
void prefetch(ExecutorType ex, void* ptr, size_t numBytes);
----
_Constraints_: Available only if `ExecutorType` is `sycl::handler`.

_Effects_: Enqueues a `prefetch` to the executor `ex`.

[source,c++]
----
template <typename ExecutorType>
void prefetch(ExecutorType ex, void* ptr, size_t numBytes, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);
----
_Constraints_: Available only if `ExecutorType` is `sycl::queue`.

_Effects_: Enqueues a `prefetch` to the executor `ex`. The command will not
execute until each of the events in `depEvents` is complete. An optional event
representing this command can be returned via `outEvent`.

[source,c++]
----
template <typename ExecutorType>
void mem_advise(ExecutorType ex, void* ptr, size_t numBytes, int advice);
----
_Constraints_: Available only if `ExecutorType` is `sycl::handler`.

_Effects_: Enqueues a `mem_advise` to the executor `ex`.

[source,c++]
----
template <typename ExecutorType>
void mem_advise(ExecutorType ex, void* ptr, size_t numBytes, int advice, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);
----
_Constraints_: Available only if `ExecutorType` is `sycl::queue`.

_Effects_: Enqueues a `mem_advise` to the executor `ex`. The command will not
execute until each of the events in `depEvents` is complete. An optional event
representing this command can be returned via `outEvent`.


=== Command barriers

The functions in this section are only available if the
link:../supported/sycl_ext_oneapi_enqueue_barrier.asciidoc[
  sycl_ext_oneapi_enqueue_barrier] extension is supported.

[source,c++]
----
namespace sycl::ext::oneapi::experimental {

template <typename ExecutorType>
void barrier(ExecutorType ex);

template <typename ExecutorType>
void barrier(ExecutorType ex, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);

template <typename ExecutorType>
void partial_barrier(ExecutorType ex);

template <typename ExecutorType>
void partial_barrier(ExecutorType ex, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);

}
----

[source,c++]
----
template <typename ExecutorType>
void barrier(ExecutorType ex);
----
_Constraints_: Available only if `ExecutorType` is `sycl::handler`.

_Effects_: Enqueues a command barrier to the executor `ex`. Any commands
submitted after this barrier cannot begin execution until all commands
previously submitted to the associated `queue` (and any commands associated
with dependendent events associated with the handler) have completed. An
optional event representing this command can be returned via `outEvent`.

[source,c++]
----
template <typename ExecutorType>
void barrier(ExecutorType ex, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);
----
_Constraints_: Available only if `ExecutorType` is `sycl::queue`.

_Effects_: Enqueues a command barrier to the executor `ex`. Any commands
submitted after this barrier cannot begin execution until all commands
previously submitted to the associated `queue` (and any commands associated
with events explicitly listed in `depEvents`) have completed. An optional event
representing this command can be returned via `outEvent`.

[source,c++]
----
template <typename ExecutorType>
void partial_barrier(ExecutorType ex);
----
_Constraints_: Available only if `ExecutorType` is `sycl::handler`.

_Effects_: Enqueues a _partial_ command barrier to the executor `ex`. Any
commands submitted after this barrier cannot begin execution until all commands
associated with any dependent events associated with the handler (i.e., via
`depends_on`) have completed.

[source,c++]
----
template <typename ExecutorType>
void partial_barrier(ExecutorType ex, const std::vector<event>& depEvents = {}, event* outEvent = nullptr);
----
_Constraints_: Available only if `ExecutorType` is `sycl::queue`.

_Effects_: Enqueues a _partial_ command barrier to the executor `ex`. Any
commands submitted after this barrier cannot begin execution until all commands
associated with events listed in `depEvents` have completed. An optional event
representing this command can be returned via `outEvent`.

[NOTE]
====
If `depEvents` is empty, a partial barrier is not required to wait for any
commands unless the `queue` is in-order. Implementations may be able to
optimize such partial barriers.
====


== Issues

. How should functions accepting `kernel` objects behave?
+
--
*UNRESOLVED*: Ideally, we would have new function names for these cases, since
they have a very different usage model. Unlike other enqueues, functions
accepting `kernel` objects currently require a developers to call
`set_arg` on the handler. Accepting kernel arguments via a parameter pack would
be more developer-friendly, but would not be compatible with the current
positioning of the `depEvents` and `event` parameters. Bundling a kernel object
with its arguments via an intermediate object may be a good alternative.
--

. What about `accessor` overloads and `update_host`?
+
--
*UNRESOLVED*: Supporting `accessor` overloads with this new approach is
possible, but additional design work is required to understand how to handle
placeholder accessors. Whether `update_host` should be exposed via this new
free-function interface is an open question.
--
